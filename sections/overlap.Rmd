---
title: "Results - extras"
output: html_document
date: "2024-11-18"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


## This was in the old OVERLAP section (overlap.Rmd) and some will be distributed to other sections
The number of words that are unique to a single resource (i.e., selected by one resource and no other) is quite high by comparison, with `r max(plot_a_data$n)` (representing `r max(plot_a_data$prop)`% of all words). The number of unique words (to a quantity of _n_ sources) decreases as the number of resources increases (Figure XX), which again demonstrates the general tendency for programs to select words in an idiosyncratic fashion; it becomes increasingly unlikely that programs agree on important words for instruction the more words one considers. This trend holds even when removing the words in Kilpatrick's program (Panel B), though the number of words that all the other five programs share increases considerably (from 28 words to 79 words). The results also indicate that the overlap between programs can't be characterized by a lot of near-misses (i.e., programs containing mostly the same words). Such a distribution would skew the other direction.


The words present only in a single resource vary in terms of their structure and meaning. These words include relatively uncommon words like "yacht", "sovereign", "spatula", "whom", "etiquette", and "gnat" to words that are quite common, like "shoe", "snow", "dry", "last", "seem", and "easy". A sample of 50 of these words with their frequencies can be found in Table X (a full list of these words can be found in the supplement online).


We've provided several analyses designed to understand the extent to which programs overlap in the words they select, and how many words are selected idiosyncratically by the programs included in the study. As a final perspective on this question, Figure XX depicts every word for the six lists arranged by increasing frequency, where each word is a tile. If a tile is shaded in, then that word is present in the program. The inconsistent ways in which lists select words is visually depicted by the inconsistent way in which the black tiles extend horizontally across the plot. While examining the data at this scale abstracts away from the identities of the words depicted, it demonstrates the general trend in large scale: words tend not to be shared across the lists. By arranging words in terms of their frequency, we are able to see that lists vary in how much frequency plays a part in the selection criteria for words. This is discussed in more detail in the next sections alongside other results concerning the underlying properties of the words present in each of these resources.

## Discussion
The concept of treating words as special is common to all the resources, but the words they identify as such are not. Only 28 words are shared by all six resources analyzed here, representing only 3% of the all unique words across all resources.

```{r}
number_of_words_in_only_one_resource_without_kilpatrick = counts_by_source_without_kilpatrick %>% 
  filter(count == 1) %>% 
  summarise(counts = sum(counts)) %>% 
  pull(counts)


number_unique_words_without_kilpatrick = all_lists %>% 
  filter(source != "kilpatrick") %>% 
  distinct(word) %>% 
  nrow()

number_of_words_in_only_one_resource = counts_by_source %>% 
  filter(count == 1) %>% 
  summarise(counts = sum(counts)) %>% 
  pull(counts)


number_of_words_in_kilpatrick_and_no_other = counts_by_source %>% 
  filter(count == 1 & source == "kilpatrick") %>% 
  pull(counts)


number_of_words_in_kilpatrick = all_lists %>% 
  filter(source == "kilpatrick") %>% 
  distinct(word) %>% 
  nrow()


number_of_words_in_fp_and_no_other = counts_by_source %>% 
  filter(count == 1 & source == "fountas_pinnell") %>% 
  pull(counts)

number_of_words_in_fp = all_lists %>% 
  filter(source == "fountas_pinnell") %>% 
  distinct(word) %>% 
  nrow()

number_of_words_in_kilpatrick_and_no_other = counts_by_source %>% 
  filter(count == 1 & source == "kilpatrick") %>% 
  pull(counts)


number_of_words_in_kilpatrick = all_lists %>% 
  filter(source == "kilpatrick") %>% 
  distinct(word) %>% 
  nrow()


```

By contrast, many more words (`r number_of_words_in_only_one_resource`) are present in a single resource, representing over half (`r round(number_of_words_in_only_one_resource/length(unique(all_lists$word)), digits = 2)*100`%) of the unique words that can be found across all six programs. While this value drops considerably when removing the Kilpatrick program (`r number_of_words_in_only_one_resource_without_kilpatrick`; `r format(round(number_of_words_in_only_one_resource_without_kilpatrick/number_unique_words_without_kilpatrick, digits = 2), nsmall = 2)`), the observation still holds. This suggests that instructional approaches tend to select words in an idiosyncratic way, not bound by selection principles that are similar to those of other programs. The tendency to idiosyncratically select words that are in no (or few) other programs varies across the resources as well. For example, the Kilpatrick program has the strong tendency to select words not selected by other programs (`r number_of_words_in_kilpatrick_and_no_other` of all words across six programs are unique to Kilpatrick; `r round(number_of_words_in_kilpatrick_and_no_other/number_of_words_in_kilpatrick, digits = 2)*100`% of words). Fountas & Pinnell is the next most likely to select words not present in any other programs with `r number_of_words_in_fp_and_no_other` words (`r round(number_of_words_in_fp_and_no_other/number_of_words_in_fp, digits = 2)*100`%).

Other programs are more likely to select words that at least some of the other programs also select. Fundations contains a distribution more indicative of such a profile, with `r counts_by_source %>% filter(source == "fundations" & count == 6) %>%  pull(prop) %>% round(digits = 2)*100`% of those words appearing in all other resources and `r counts_by_source %>% filter(source == "fundations" & count == 5) %>%  pull(prop) %>% round(digits = 2)*100`% of words appearing in five other resources. However, even here many words are idiosyncratic to this program, with `r counts_by_source %>% filter(source == "fundations" & count == 1) %>%  pull(prop) %>% round(digits = 2)*100`% of words (`r counts_by_source %>% filter(source == "fundations" & count == 1) %>%  pull(counts)` words) found only in this list and no other.

In summary, these findings suggest something troubling about the experiences of children learning to read from these popular instructional resources: their experiences differ in terms of the words that they learn how to read. The next section concerns the properties of the words found in these resources, considering the possibility that programs agree on the _structure_ (and other properties) of the words selected despite selecting different words for use in the classroom.
